\documentclass{article}

%\include{macros}

\bibliographystyle{plain}

\usepackage{epsfig}
\usepackage{xcolor}
\usepackage{amsmath}
%%\usepackage{amssymb}
\input{alias.tex}
\begin{document}

\title{Serial comparison of Proto-based an fortran-based elliptic operators}
\author{D. T. Graves   }
\date{February 2, 2024 ce.}

\maketitle


\section{Context}

Chombo solves elliptic equations using the framework in AMRElliptic.
The driving classes ({\tt AMRMultigrid, Multigrid, BiCGStabSolver,
  RelaxSolver} and so on) are templated on data type.  The operator
base classses {\tt AMRLevelOp, MGLevelOp}, and {\tt LinearOp} describe
the interface to which an operator much conform to be used by these
driver classes.    This framework has been shown to be very flexible
as operators in many different contexts have been able to use the
driver framework.

This operator framework is large, however.   The {\tt AMRLevelOp}
class hierarchy describes dozens of virtual functions.    Over time,
optimization efforts have expanded this interface a lot.  This means
writing  one of these classes can be taxing.

The elliptic operators in {\tt Chombo/lib/src/AMRElliptic}
are templated on  {\tt LevelData<FArrayBox>} and the all computation
and memory is on the host.   These shall be referred to as the
fortran-based  operators because they all drop to fortran kernels.

The corresponding elliptic operators in {\tt  Chombo/releasedExamples/Proto/common}
are templated on proto's {\tt LevelBoxData}.   All computation by and
memory for the operator is  on the device.  These shall be referred to
as the proto-based elliptic operators.

There are two purposes for this test framework.
\begin{itemize}
\item Minimize the operator interface and measure the consequences.
  The This will have performance
  penalties but those are measurable.   I am very curious as to how
  big those penalties are and I will expend some effort to find out.
\item Use the proto infrastructure to implement a selection of
  operators on the device and compare their times to the equivalent
  fortran-based operators on the host.
\end{itemize}
Mostly I just want to get everything running in all the configuations
Though we will vary a bunch of things, this particular test will be
kept simple.
\begin{itemize}
  \item All computations on the host (specfically, spencer.lbl.gov).
  \item All computations are in serial.
  \item All runs have Dirichlet boundary conditions and very simple
    grids.
  \item All input files are pretty forgiving in terms of solvability
    and so on (coefficients set to reasonable constants and so on).
  \item The varying input files are really just making bigger grids
\end{itemize}
 Later frameworks will address GPU and MPI issues.

 \section{Test description}

 There are eight operator classes we are considering:
 \begin{itemize}
 \item {\tt Proto Helmholtz Op} (constant coefficient Helmholtz on
   device.)
 \item {\tt AMRPoissonOp} (constant coefficient Helmholtz on   host).
 \item {\tt VCAMRPoissonOp2} (variable coefficient Helmholtz on host).
 \item {\tt ViscousTensorOp} (viscous tensor on host).
 \item {\tt ResistivityOp} (resistivity on host).
 \item {\tt Proto\_Helmholtz\_Op} (constant coefficient Helmholtz on device).
 \item {\tt Proto\_Conductivity\_Op} (variable coefficient Helmholtz on device).
 \item {\tt Proto\_Viscous Tensor\_Op} (viscous tensor on device).
 \item {\tt Proto\_Resistivity\_Op} (resistivity on device).
 \end{itemize}

 Each class is run for both two and three dimensions.   Each operator
 is run with input files for four separate cases.    
 \begin{itemize}
   \item {\tt case\_0.inputs}: $maxlev = 0, ncells = 32^D$.
   \item {\tt case\_1.inputs}: $maxlev = 1, ncells = 32^D$.
   \item {\tt case\_2.inputs}: $maxlev = 2, ncells = 32^D$.
   \item {\tt case\_3.inputs}: $maxlev = 2, ncells = 64^D$.
 \end{itemize}
 If you are keeping track, this should amount to 64 runs.

\section{Results}

\subsection{Convergence}
I did the runs and everything ran.   Not everything ran well.   Some
operators (old and new) did not converge well.   Here I plot the final
residual and the number of multigrid iterations it took to get there.

\begin{small}
\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c}} \hline
Operator & $D$ & Case & Final Resid & Num. Iter \\
\hline
{\tt Proto\_Helmholtz\_Op} & 2  & 0   & 7.815970e-14  & \\
{\tt Proto\_Helmholtz\_Op} & 2  & 1   & 6.163958e-13  & \\
{\tt Proto\_Helmholtz\_Op} & 2  & 2   & 5.520029e-13  & \\
{\tt Proto\_Helmholtz\_Op} & 2  & 3   & 7.061018e-13  & \\
{\tt Proto\_Helmholtz\_Op} & 3  & 0   & 7.815970e-14  & \\
Looks suspicious---probably not doing dim==3

{\tt Proto\_Helmholtz\_Op} & 3  & 1   &   & \\
{\tt Proto\_Helmholtz\_Op} & 3  & 2   &   & \\
{\tt Proto\_Helmholtz\_Op} & 3  & 3   &   & \\
\hline
\end{tabular}
\end{center}
\label{tab::convergence}
\caption
 {
   Final residual and number of iterations used for various runs.
 }
\end{table}
\end{small}

\section{Conclusions}



\end{document}
